/*

    Copyright (c) 2015 Oliver Lau <ola@ct.de>, Heise Medien GmbH & Co. KG

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include <QDebug>
#include <string>
#include "3rdparty/cryptopp562/sha.h"
#include "3rdparty/cryptopp562/aes.h"
#include "3rdparty/cryptopp562/ccm.h"
#include "3rdparty/cryptopp562/filters.h"
#include "3rdparty/cryptopp562/misc.h"
#include "securebytearray.h"
#include "pbkdf2.h"
#include "crypter.h"
#include "util.h"
#include "global.h"


const int Crypter::SaltSize = 32;
const int Crypter::AESKeySize = 256 / 8;
const int Crypter::KGKIterations = 1024;
const int Crypter::KGKSize = 64;
const int Crypter::AESBlockSize = CryptoPP::AES::BLOCKSIZE;
const int Crypter::EEKSize = Crypter::SaltSize + Crypter::AESBlockSize + Crypter::KGKSize;

/*!
 * \brief Crypter::encode
 *
 * This function encrypts a block of data with the given encryption key.
 *
 * The encryption key itself is encrypted with the given master key.
 *
 * \param key An AES key generated from the user's master password.
 * \param IV AES initialization vector. A randomly generated byte sequence of `CryptoPP::AES::BLOCKSIZE` length.
 * \param KGK Key generation key. A randomly generated byte sequence of `Crypter::KGKSize` length.
 * \param salt A 32 byte salt.
 * \param data The data to be encrypted.
 * \param compress If `true`, data will be compressed before encryption.
 * \param errCode Will be set to a code that tells the caller what might have gone wrong while encryption.
 * \param errMsg `errCode` as a readable message.
 * \return Block of binary data with the following structure:
 *
 * Bytes   | Description
 * ------- | ---------------------------------------------------------------------------
 *       1 | Format flag (must be 0x01)
 *      32 | Salt (randomly generated)
 *      80 | Encrypted data: 32 bytes randomly generated salt, 16 bytes bytes randomly IV, 64 bytes key generation key.
 *       n | Encrypted data
 *
 */
QByteArray Crypter::encode(const SecureByteArray &key,
                           const SecureByteArray &IV,
                           const QByteArray &salt,
                           const SecureByteArray &KGK,
                           const QByteArray &data,
                           bool compress,
                           int *errCode, QString *errMsg)
{
  Q_ASSERT_X(KGK.size() == KGKSize, "Crypter::encode()", "KGK.size() must be KGKSize");

  if (errCode != nullptr)
    *errCode = NoCryptError;

  SecureByteArray KGK2;
  const QByteArray salt2(randomBytes(SaltSize));
  KGK2.append(salt2);
  const QByteArray IV2(randomBytes(CryptoPP::AES::BLOCKSIZE));
  KGK2.append(IV2);
  KGK2.append(KGK);
  qDebug() << "KGK2.size()=" << KGK2.size();
  Q_ASSERT_X(KGK2.size() % AESBlockSize == 0, "Crypter::encode()", "KGK2.size() must be a multiple of AESBlockSize");
  Q_ASSERT_X(KGK2.size() == EEKSize, "Crypter::encode()", "bad KGK2.size()");

  // encrypt key
  std::string sKGK(KGK2.constData(), KGK2.size());
  std::string sEEK;
  try {
    CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption enc;
    enc.SetKeyWithIV(reinterpret_cast<const byte*>(key.constData()), key.size(), reinterpret_cast<const byte*>(IV.constData()));
    CryptoPP::ArraySource s(
          sKGK,
          true,
          new CryptoPP::StreamTransformationFilter(
            enc,
            new CryptoPP::StringSink(sEEK),
            CryptoPP::StreamTransformationFilter::NO_PADDING
            )
          );
    Q_UNUSED(s); // just to please the compiler
  }
  catch(const CryptoPP::Exception &e)
  {
    if (errCode != nullptr)
      *errCode = (int)e.GetErrorType();
    if (errMsg != nullptr)
      *errMsg = e.what();
    if (e.GetErrorType() > NoCryptError)
      qErrnoWarning(e.GetErrorType(), e.what());
  }
  QByteArray EEK(sEEK.c_str(), sEEK.length());
  qDebug() << "EEK.size()=" << EEK.size();
  Q_ASSERT_X(EEK.size() == EEKSize, "Crypter::encode()", "bad EEK.size()");

  // encrypt data
  const SecureByteArray &blobKey = Crypter::makeKeyFromPassword(KGK, salt2, KGKIterations);
  Q_ASSERT_X(blobKey.size() == AESKeySize, "Crypter::encode()", "blobKey.size() must equal AES key size");

  QByteArray _baPlain = compress ? qCompress(data, 9) : data;
  std::string plain(_baPlain.constData(), _baPlain.length());
  std::string cipher;
  try {
    CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption enc;
    enc.SetKeyWithIV(reinterpret_cast<const byte*>(blobKey.constData()), blobKey.size(), reinterpret_cast<const byte*>(IV2.constData()));
    CryptoPP::StringSource s(
          plain,
          true,
          new CryptoPP::StreamTransformationFilter(
            enc,
            new CryptoPP::StringSink(cipher),
            CryptoPP::StreamTransformationFilter::PKCS_PADDING
            )
          );
    Q_UNUSED(s); // just to please the compiler
  }
  catch(const CryptoPP::Exception &e)
  {
    if (errCode != nullptr)
      *errCode = (int)e.GetErrorType();
    if (errMsg != nullptr)
      *errMsg = e.what();
    if (e.GetErrorType() > NoCryptError)
      qErrnoWarning(e.GetErrorType(), e.what());
  }

  QByteArray baCipher(cipher.c_str(), cipher.length());
  QByteArray result;
  result.append(AES256EncryptedMasterkeyFormat);
  result.append(salt);
  result.append(EEK);
  result.append(baCipher);
  return result;
}

/*!
 * \brief Crypter::decode
 * \param key An AES key generated from the user's master password.
 * \param IV AES initialization vector. A randomly generated byte sequence of `CryptoPP::AES::BLOCKSIZE` length.
 * \param KGK Key generation key. A randomly generated byte sequence of `Crypter::AESKeySize` length.
 * \param salt A 32 byte salt.
 * \param baCipher The data to be decrypted.
 * \param compress If `true`, data will be compressed before encryption.
 * \param errCode Will be set to a code that tells the caller what might have gone wrong while encryption.
 * \param errMsg `errCode` as a readable message.
 * \return
 */
QByteArray Crypter::decode(const SecureByteArray &masterPassword,
                           QByteArray baCipher,
                           bool uncompress,
                           int *errCode,
                           QString *errMsg)
{
  if (errCode != nullptr)
    *errCode = NoCryptError;
  FormatFlags formatFlag = static_cast<FormatFlags>(baCipher.at(0));
  Q_ASSERT_X(formatFlag == AES256EncryptedMasterkeyFormat, "Crypter::decode()", "formatFlag must equal AES256EncryptedMasterkeyFormat");
  baCipher.remove(0, 1);

  const QByteArray &salt = QByteArray(baCipher.constData(), SaltSize);
  baCipher.remove(0, SaltSize);

  SecureByteArray EEK;
  EEK = QByteArray(baCipher.constData(), EEKSize);
  baCipher.remove(0, EEKSize);

  SecureByteArray key;
  SecureByteArray IV;
  Crypter::makeKeyAndIVFromPassword(masterPassword, salt, KGKIterations, key, IV);

  // decrypt key
  std::string sRecoveredKGK;
  try {
    CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption dec;
    dec.SetKeyWithIV(reinterpret_cast<const byte*>(key.constData()), key.size(), reinterpret_cast<const byte*>(IV.constData()));
    std::string cipher(EEK.constData(), EEK.size());
    CryptoPP::ArraySource s(
          cipher,
          true,
          new CryptoPP::StreamTransformationFilter(
            dec,
            new CryptoPP::StringSink(sRecoveredKGK)
            )
          );
    Q_UNUSED(s); // just to please the compiler
  }
  catch(const CryptoPP::Exception &e)
  {
    if (errCode != nullptr)
      *errCode = (int)e.GetErrorType();
    if (errMsg != nullptr)
      *errMsg = e.what();
    if (e.GetErrorType() > NoCryptError)
      qErrnoWarning(e.GetErrorType(), e.what());
  }
  QByteArray baKGK(sRecoveredKGK.c_str(), sRecoveredKGK.length());
  Q_ASSERT_X(baKGK.size() == AESKeySize + SaltSize + KGKSize, "Crypter::encode()", "bad baKGK.size()");

  QByteArray salt2(baKGK.constData(), SaltSize);
  baKGK.remove(0, SaltSize);
  QByteArray IV2(baKGK.constData(), AESBlockSize);
  baKGK.remove(0, AESBlockSize);
  QByteArray KGK(baKGK.constData(), KGKSize);

  const SecureByteArray &blobKey = Crypter::makeKeyFromPassword(KGK, salt2, KGKIterations);
  std::string sRecovered;
  try {
    CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption dec;
    dec.SetKeyWithIV(reinterpret_cast<const byte*>(blobKey.constData()), blobKey.size(), reinterpret_cast<const byte*>(IV2.constData()));
    std::string cipher(EEK.constData(), EEK.size());
    CryptoPP::ArraySource s(
          cipher,
          true,
          new CryptoPP::StreamTransformationFilter(
            dec,
            new CryptoPP::StringSink(sRecovered)
            )
          );
    Q_UNUSED(s); // just to please the compiler
  }
  catch(const CryptoPP::Exception &e)
  {
    if (errCode != nullptr)
      *errCode = (int)e.GetErrorType();
    if (errMsg != nullptr)
      *errMsg = e.what();
    if (e.GetErrorType() > NoCryptError)
      qErrnoWarning(e.GetErrorType(), e.what());
  }
  QByteArray plain(sRecovered.c_str(), sRecovered.length());
  return uncompress ? qUncompress(plain) : plain;
}


QByteArray Crypter::randomBytes(int size)
{
  QByteArray salt(size, static_cast<char>(0));
  for (int i = 0; i < salt.size(); ++i)
    salt[i] = static_cast<char>(gRandomDevice());
  return salt;
}


SecureByteArray Crypter::makeKeyFromPassword(const SecureByteArray &masterPassword, const QByteArray &salt, int iterations)
{
  PBKDF2 cryptPassword;
  cryptPassword.setIterations(iterations);
  cryptPassword.setSalt(salt);
  cryptPassword.generate(masterPassword, QCryptographicHash::Sha256);
  return cryptPassword.derivedKey(Crypter::AESKeySize);
}


void Crypter::makeKeyAndIVFromPassword(const SecureByteArray &masterPassword, const QByteArray &salt, int iterations, SecureByteArray &key, SecureByteArray &IV)
{
  Q_ASSERT(key.size() == AESKeySize);
  Q_ASSERT(IV.size() == AESBlockSize);
  PBKDF2 cryptPassword;
  cryptPassword.setIterations(iterations);
  cryptPassword.setSalt(salt);
  cryptPassword.generate(masterPassword, QCryptographicHash::Sha384);
  const SecureByteArray &hash = cryptPassword.derivedKey();
  qDebug() << "HASH:" << hash.toHex();
  key = hash.mid(0, AESKeySize);
  IV = hash.mid(AESKeySize, AESBlockSize);
}
